package service

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/deepalert/deepalert"
	"github.com/deepalert/deepalert/internal/adaptor"
	"github.com/deepalert/deepalert/internal/models"
	"github.com/google/uuid"
	"github.com/m-mizutani/golambda"
)

/*
	DynamoDB Design

	Data models
	- Alert : Generated by a security monitoring device. It has attribute(s).
	- Attribute : Values appeared in an Alert (e.g. IP address, domain name, user name, etc.)
	- Content : A result of attribute inspection by Inspector
	- Report : All results. It consists of Alert(S), Content(S) and a result of Reviewer.


	Keys
	- AlertID : Generated by Alert.Detector, Alert.RuneName and Alert.AlertKey.
	- ReportID : Assigned to unique AlertKey and time range. Same AlertID can have multiple
				ReportID if timestamps of alert are distant from each other.
	- AttrHash: Hashed value of an attribute, generated by all fields of Attribute.

	Primary/secondary key design (in "pk", "sk" field and stored data)
	- alertmap/{AlertID}, fixedkey -> ReportID
	- alert/{ReportID}, cache/{random} -> Alert(s)
	- content/{ReportID}, {AttrHash}/{Random} -> Content(S)
	- attribute/{ReportID}, {AttrHash} -> Attribute (for caching)
*/

const (
	alertMapfixedKey = "-"
)

// RepositoryService is interface of data repository. This is designed to be used with DynamoDB, but adaptor.Repository can be replaced with other repository. (e.g. mock.Repository)
type RepositoryService struct {
	repo adaptor.Repository
	ttl  time.Duration
}

// NewRepositoryService is constructor of RepositoryService. ttl is used to calculate ExpiresAt by now + ttl * time.Second
func NewRepositoryService(repo adaptor.Repository, ttl int64) *RepositoryService {
	return &RepositoryService{
		repo: repo,
		ttl:  time.Duration(ttl) * time.Second,
	}
}

// -----------------------------------------------------------
// Control alertEntry to manage AlertID to ReportID mapping
//

func newReportID() deepalert.ReportID {
	return deepalert.ReportID(uuid.New().String())
}

func toAlertMapPKey(alertID string) string {
	return "alertmap/" + alertID
}

func (x *RepositoryService) TakeReport(alert deepalert.Alert, now time.Time) (*deepalert.Report, error) {
	alertID := alert.AlertID()

	entry := models.AlertEntry{
		RecordBase: models.RecordBase{
			PKey:      toAlertMapPKey(alertID),
			SKey:      alertMapfixedKey,
			ExpiresAt: now.UTC().Add(x.ttl).Unix(),
			CreatedAt: now.UTC().Unix(),
		},
		ReportID: newReportID(),
	}

	if err := x.repo.PutAlertEntry(&entry, now); err != nil {
		if x.repo.IsConditionalCheckErr(err) {
			existedEntry, err := x.repo.GetAlertEntry(entry.PKey, entry.SKey)
			if err != nil {
				return nil, golambda.WrapError(err, "Fail to get cached reportID").With("AlertID", alertID)
			}

			return &deepalert.Report{
				ID:        existedEntry.ReportID,
				Status:    deepalert.StatusMore,
				CreatedAt: time.Unix(existedEntry.CreatedAt, 0),
			}, nil
		}

		return nil, golambda.WrapError(err, "Fail to create new alert entry").
			With("AlertID", alertID).With("repo", x.repo)
	}

	return &deepalert.Report{
		ID:        entry.ReportID,
		Status:    deepalert.StatusNew,
		CreatedAt: now,
	}, nil
}

func (x *RepositoryService) GetReportID(alertID string) (deepalert.ReportID, error) {

	existedEntry, err := x.repo.GetAlertEntry(toAlertMapPKey(alertID), alertMapfixedKey)
	if err != nil {
		return deepalert.NullReportID, golambda.WrapError(err, "Fail to get cached reportID").With("AlertID", alertID)
	} else if existedEntry == nil {
		return deepalert.NullReportID, nil
	}

	return existedEntry.ReportID, nil
}

// -----------------------------------------------------------
// Control alertCache to manage published alert data
//

func toAlertCacheKey(reportID deepalert.ReportID) (string, string) {
	return fmt.Sprintf("alert/%s", reportID), "cache/" + uuid.New().String()
}

func (x *RepositoryService) SaveAlertCache(reportID deepalert.ReportID, alert deepalert.Alert, now time.Time) error {
	raw, err := json.Marshal(alert)
	if err != nil {
		return golambda.WrapError(err, "Fail to marshal alert").With("alert", alert)
	}

	pk, sk := toAlertCacheKey(reportID)
	cache := &models.AlertCache{
		RecordBase: models.RecordBase{
			PKey:      pk,
			SKey:      sk,
			ExpiresAt: now.UTC().Add(x.ttl).Unix(),
		},
		AlertData: raw,
	}

	if err := x.repo.PutAlertCache(cache); err != nil {
		return err
	}

	return nil
}

func (x *RepositoryService) FetchAlertCache(reportID deepalert.ReportID) ([]*deepalert.Alert, error) {
	pk, _ := toAlertCacheKey(reportID)
	var alerts []*deepalert.Alert

	caches, err := x.repo.GetAlertCaches(pk)
	if err != nil {
		return nil, golambda.WrapError(err, "GetAlertCaches").With("reportID", reportID)
	}

	for _, cache := range caches {
		var alert deepalert.Alert
		if err := json.Unmarshal(cache.AlertData, &alert); err != nil {
			return nil, golambda.WrapError(err, "Fail to unmarshal alert").With("data", string(cache.AlertData))
		}
		alerts = append(alerts, &alert)
	}

	return alerts, nil
}

// -----------------------------------------------------------
// Control reportRecord to manage report contents by inspector
//

func toFindingKeys(reportID deepalert.ReportID, inspect *deepalert.Finding) (string, string) {
	pk := fmt.Sprintf("content/%s", reportID)
	sk := ""
	if inspect != nil {
		sk = fmt.Sprintf("%s/%s", inspect.Attribute.Hash(), uuid.New().String())
	}
	return pk, sk
}

func (x *RepositoryService) SaveFinding(section deepalert.Finding, now time.Time) error {
	raw, err := json.Marshal(section)
	if err != nil {
		return golambda.WrapError(err, "Fail to marshal Section").With("section", section)
	}

	pk, sk := toFindingKeys(section.ReportID, &section)
	record := &models.InspectorReportRecord{
		RecordBase: models.RecordBase{
			PKey:      pk,
			SKey:      sk,
			ExpiresAt: now.UTC().Add(x.ttl).Unix(),
		},
		Data: raw,
	}

	if err := x.repo.PutInspectorReport(record); err != nil {
		return golambda.WrapError(err, "Fail to put report record")
	}

	return nil
}

func (x *RepositoryService) FetchSection(reportID deepalert.ReportID) ([]*deepalert.Section, error) {
	pk, _ := toFindingKeys(reportID, nil)

	records, err := x.repo.GetInspectorReports(pk)
	if err != nil {
		return nil, err
	}

	var reports []*deepalert.Finding
	for _, record := range records {
		var section deepalert.Finding
		if err := json.Unmarshal(record.Data, &section); err != nil {
			return nil, golambda.WrapError(err, "Fail to unmarshal report content").
				With("record", record).
				With("data", string(record.Data))
		}

		reports = append(reports, &section)
	}

	sections, err := remapSection(reports)
	if err != nil {
		return nil, golambda.WrapError(err, "Failed to remap Finding")
	}
	return sections, nil
}

func rebuildCotent(src interface{}, dst interface{}) error {
	raw, err := json.Marshal(src)
	if err != nil {
		return golambda.NewError("Failed to marshal content")
	}
	if err := json.Unmarshal(raw, dst); err != nil {
		return golambda.WrapError(err, "Failed to unmarshal marshaled content").With("raw", string(raw))
	}

	return nil
}

func remapSection(inspectReports []*deepalert.Finding) ([]*deepalert.Section, error) {
	sections := map[string]*deepalert.Section{}

	for _, ir := range inspectReports {
		hv := ir.Attribute.Hash()
		section, ok := sections[hv]
		if !ok {
			section = &deepalert.Section{
				Attr: ir.Attribute,
			}
			sections[hv] = section
		}
		switch ir.Type {
		case deepalert.ContentTypeHost:
			var c deepalert.ContentHost
			if err := rebuildCotent(ir.Content, &c); err != nil {
				return nil, golambda.WrapError(err, "Invalid deepalert.ContentHost data")
			}
			section.Hosts = append(section.Hosts, &c)

		case deepalert.ContentTypeUser:
			var c deepalert.ContentUser
			if err := rebuildCotent(ir.Content, &c); err != nil {
				return nil, golambda.WrapError(err, "Invalid deepalert.ContentUser data")
			}
			section.Users = append(section.Users, &c)

		case deepalert.ContentTypeBinary:
			var c deepalert.ContentBinary
			if err := rebuildCotent(ir.Content, &c); err != nil {
				return nil, golambda.WrapError(err, "Invalid deepalert.ContentBinary data")
			}
			section.Binaries = append(section.Binaries, &c)
		}
	}

	var sectionList []*deepalert.Section
	for _, section := range sections {
		sectionList = append(sectionList, section)
	}
	return sectionList, nil
}

// -----------------------------------------------------------
// Control attribute cache to prevent duplicated invocation of Inspector with same attribute
//

func toAttributeCacheKey(reportID deepalert.ReportID) string {
	return fmt.Sprintf("attribute/%s", reportID)
}

func toReportKey(reportID deepalert.ReportID) string {
	return fmt.Sprintf("report/%s", reportID)
}

// IsReportStreamEvent checks if the record has reportKey
func IsReportStreamEvent(record *events.DynamoDBEventRecord) bool {
	pk, ok := record.Change.Keys[models.DynamoPKeyName]
	if !ok {
		return false
	}
	return strings.HasPrefix(pk.String(), "report/")
}

// PutAttributeCache puts attributeCache to DB and returns true. If the attribute alrady exists,
// it returns false.
func (x *RepositoryService) PutAttributeCache(reportID deepalert.ReportID, attr deepalert.Attribute, now time.Time) (bool, error) {
	var ts time.Time
	if attr.Timestamp != nil {
		ts = *attr.Timestamp
	} else {
		ts = now
	}

	cache := &models.AttributeCache{
		RecordBase: models.RecordBase{
			PKey:      toAttributeCacheKey(reportID),
			SKey:      attr.Hash(),
			ExpiresAt: now.Add(x.ttl).Unix(),
		},
		Timestamp:   ts,
		AttrKey:     attr.Key,
		AttrType:    string(attr.Type),
		AttrValue:   attr.Value,
		AttrContext: attr.Context,
	}

	if err := x.repo.PutAttributeCache(cache, now); err != nil {
		if x.repo.IsConditionalCheckErr(err) {
			// The attribute already exists
			return false, nil
		}

		return false, golambda.WrapError(err, "Fail to put attr cache").
			With("reportID", reportID).
			With("attr", attr)
	}

	return true, nil
}

// FetchAttributeCache retrieves all cached attribute from DB.
func (x *RepositoryService) FetchAttributeCache(reportID deepalert.ReportID) ([]*deepalert.Attribute, error) {
	pk := toAttributeCacheKey(reportID)

	caches, err := x.repo.GetAttributeCaches(pk)
	if err != nil {
		return nil, golambda.WrapError(err, "Fail to retrieve attributeCache").With("reportID", reportID)
	}

	var attrs []*deepalert.Attribute
	for _, cache := range caches {
		attr := deepalert.Attribute{
			Type:      deepalert.AttrType(cache.AttrType),
			Key:       cache.AttrKey,
			Value:     cache.AttrValue,
			Context:   cache.AttrContext,
			Timestamp: &cache.Timestamp,
		}

		attrs = append(attrs, &attr)
	}

	return attrs, nil
}

// PutReport puts report with a key based on report.ID
func (x *RepositoryService) PutReport(report *deepalert.Report) error {
	pk := toReportKey(report.ID)
	if err := x.repo.PutReport(pk, report); err != nil {
		return err
	}
	return nil
}

// GetReport gets a report by a key based on report.ID
func (x *RepositoryService) GetReport(reportID deepalert.ReportID) (*deepalert.Report, error) {
	pk := toReportKey(reportID)
	report, err := x.repo.GetReport(pk)
	if err != nil {
		return nil, err
	}
	return report, nil
}
